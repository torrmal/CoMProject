{"mappings":"oeAAAA,EAAA,S","sources":["src/js/demo1.js"],"sourcesContent":["import * as THREE from 'three';\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';\nimport { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler.js';\n\nfunction loadAll () {\nconst elContent = document.querySelector('.content2');\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(\n  75,\n  elContent.offsetWidth / elContent.offsetHeight,\n  0.1,\n  1000\n);\n\nconst renderer = new THREE.WebGLRenderer({\n  antialias: true\n});\nrenderer.setSize(elContent.offsetWidth, elContent.offsetHeight);\nelContent.appendChild(renderer.domElement);\n\ncamera.position.z = 1;\ncamera.position.y = 1;\ncamera.lookAt(0, 0, 0);\n\nconst group = new THREE.Group();\nscene.add(group);\n\nconst sparkles = [];\nwindow.sparkles=sparkles;\nconst sparklesGeometry = new THREE.BufferGeometry();\nconst sparklesMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    pointTexture: {\n      value: new THREE.TextureLoader().load('dotTexture.png')\n    }\n  },\n  vertexShader: document.getElementById(\"vertexshader\").textContent,\n  fragmentShader: document.getElementById(\"fragmentshader\").textContent,\n  depthTest: false,\n  depthWrite: false,\n  blending: THREE.AdditiveBlending\n});\nconst points = new THREE.Points(sparklesGeometry, sparklesMaterial);\ngroup.add(points);\n\nconst p1 = new THREE.Vector3();\nlet sampler = null;\nconst lines = [];\nlet linesColors = [new THREE.Color(0xFAAD80).multiplyScalar(0.5), new THREE.Color(0xFF6767).multiplyScalar(0.5), new THREE.Color(0xFF3D68).multiplyScalar(0.5), new THREE.Color(0xA73489).multiplyScalar(0.5)];\nfunction initLines() {\n  sampler = new MeshSurfaceSampler(turtle).build();\n  \n  for (let i = 0; i < 6; i++) {\n    sampler.sample(p1);\n    const linesMesh = {\n      colorIndex: i % 4,\n      previous: p1.clone()\n    };\n    lines.push(linesMesh);\n  }\n\n  renderer.setAnimationLoop(render);\n}\n\nlet turtle = null;\nnew OBJLoader().load(\n  \"man.obj\",\n  (obj) => {\n    turtle = obj.children[0];\n    initLines();\n  },\n  (xhr) => console.log((xhr.loaded / xhr.total) * 100 + \"% loaded\"),\n  (err) => console.error(err)\n);\n\nconst tempSparklesArrayColors = [];\nfunction findNextVector(line) {\n  let ok = false;\n  while (!ok) {\n    sampler.sample(p1);\n\n    if (p1.distanceTo(line.previous) < 2) {\n      line.previous = p1.clone();\n\n      const spark = new Sparkle();\n      spark.setup(line.previous);\n      sparkles.push(spark);\n\n      tempSparklesArrayColors.push(linesColors[line.colorIndex].r, linesColors[line.colorIndex].g, linesColors[line.colorIndex].b);\n      sparklesGeometry.setAttribute(\"color\", new THREE.Float32BufferAttribute(tempSparklesArrayColors, 3));\n      \n      ok = true;\n    }\n  }\n}\n\nclass Sparkle extends THREE.Vector3 {\n  setup(origin) {\n    this.add(origin).multiplyScalar(2);\n    this.dest = origin;\n\n    this._size = Math.random() * 5 + 0.5;\n    this.size = 1;\n    this.scaleSpeed = Math.random() * 0.03 + 0.03;\n    this.stop = false;\n  }\n  update() {\n    this.x += (this.dest.x - this.x) * 0.08;\n    this.y += (this.dest.y - this.y) * 0.08;\n    this.z += (this.dest.z - this.z) * 0.08;\n    if (this.size < this._size) {\n      this.size += this.scaleSpeed;\n    } else {\n      // if (this.distanceTo(this.dest) < 0.1) {\n      //   this.stop = true;\n      // }\n    }\n  }\n}\n\nlet tempSparklesArray = [];\nlet tempSparklesArraySizes = [];\nfunction render(a) {\n  group.rotation.y += 0.002;\n\n  if (sparkles.length < 40000) {\n    lines.forEach(l => {\n      findNextVector(l);\n      findNextVector(l);\n      findNextVector(l);\n    });\n  }\n\n  sparkles.forEach((s, i) => {\n    if (!s.stop) {\n      s.update();\n    }\n    tempSparklesArray[(i * 3)] = s.x;\n    tempSparklesArray[(i * 3) + 1] = s.y;\n    tempSparklesArray[(i * 3) + 2] = s.z;\n    tempSparklesArraySizes[i] = s.size;\n  });\n  sparklesGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(tempSparklesArray, 3));\n  //sparklesGeometry.setAttribute(\"size\", new THREE.Float32BufferAttribute(tempSparklesArraySizes, 1));\n\n  renderer.render(scene, camera);\n}\n\nwindow.addEventListener('resize', onWindowResize, false);\n\nfunction onWindowResize(){\n  camera.aspect = elContent.offsetWidth / elContent.offsetHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(elContent.offsetWidth, elContent.offsetHeight);\n}\n\n}\n"],"names":["parcelRequire"],"version":3,"file":"index.4065ee71.js.map"}